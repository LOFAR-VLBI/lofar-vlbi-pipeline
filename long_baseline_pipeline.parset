#########################################################
## LOFAR long baseline calibration pipeline parset     ##
#########################################################
# Please read the instructions and report bugs on: https://github.com/lmorabit/long_baseline_pipeline

## STEPS TO RUN#
pipeline.steps = [mk_results_dir, mk_inspect_dir, mk_cal_values_dir, mk_ionex_dir, createmap_target, createmap_ps, createmap_ps_tables, make_ps_out_mapfile, copy_sols, createmap_pstwo, match_files, ndppp_prep_target, combine_data_target_map, get_ion_files, transfer_amp_clock_sols, is_amp_gains, is_add_phase, ndppp_apply_cal, download_cats, do_parallel, find_delay_cal, prep_dirs, dppp_phaseup, make_circ, make_concatmap, sort_concatmap, do_sortmap_maps, dppp_concat, delay_cal_model, delay_cal_model_map, calib_cal, make_losoto, process_losoto, make_dppp_prep_map, copyST_gains, ndppp_apply_delay, copy_h5imp_cal ]

###########################################################################
## PARAMETER SETUP
## SECTION 1: things that absolutely need to be configured

## global information
! base_directory 		        = input.output.working_directory  ## this is taken from the config file -- DO NOT CHANGE
! job_directory		 	        = input.output.job_directory	  ## this is taken from the config file -- DO NOT CHANGE

! long_baseline_pipeline_dir 		= /home/lmorabit/long_baseline_pipeline_new
! prefactor_dir			        = /home/lmorabit/prefactor
! losoto_executable			= /home/lmorabit/losoto/bin/losoto

## target data information
! target_input_path             = /data/scratch/lb_bw/targetdata
! target_input_pattern          = L*.MS

## Prefactor solution information
! transfer_amp_clock_sols_store = /data/scratch/lb_bw/prefactor_solutions/cal_results/  ## directory with amplitude and clock solutions of prefactor (*.npy files)
! amp_sols_basename             = caldata_transfer
! phase_sol_input_path          = /data/scratch/lb_bw/prefactor_solutions/prefactor/results ## directory with measurement sets containing direction-independent phase solutions of the target fielda

! image_cat  = {{ job_directory }}/lotss_catalogue.csv
! delay_cat  = {{ job_directory }}/delay_calibrators.csv
! subtract_cat  = {{ job_directory }}/subtract_sources.csv
! do_download = True

## Averaging parameters
! cal_shift_avg_timestep        = 8    ## Calibrator time averaging: output should be 8 seconds
! cal_shift_avg_freqstep        = 8    ## Calibrator freq averaging: output should be 2 channels per subband
! tgt_shift_avg_timestep        = 16   ## Target time averaging: output should be 16 seconds
! tgt_shift_avg_freqstep        = 16   ## Target freq averaging: output should be 1 channel per subband

## Stations to flag
! flag_baselines 		= [ RS310* ] ## for HBA data before October 2015, should set to: [ CS013HBA* ]

###########################################################################
## PARAMETER SETUP
## SECTION 2: things that are probably fine as is, but should be checked

## Output directories
! results_directory             = {{ job_directory }}/results
! inspection_directory          = {{ results_directory }}/inspection/
! cal_values_directory          = {{ results_directory }}/calibrator_results/

## Station combination
! phaseup_command               = {ST001:'CS*'} ## 'CS*' for all core stations (or select stations you want to use)
! filter_command                = '!CS*&*'      ## remove the core stations after combination

## Closure phase stations
! closure_phase_stations        = 'DE601;DE605;ST001' ## list of three stations separated by ;
! closure_phase_file            = {{ job_directory }}/closure_phases.txt ## pipeline expects this location - do not change

## Runtime setup -- will depend on your computing cluster
! num_proc_per_node        	= input.output.max_per_node    ## number of processes to use per step per node
! num_proc_per_node_limit  	= 4	## number of processes to use per step per node for tasks with high i/o (dppp or cp) or memory (eg calibration)
! max_dppp_threads          	= 2	## number of threads per process for NDPPP
! error_tolerance               = False ## False = stop if any subband fails, True = keep going

## IONEX server information
# the URL of the server where  the IONEX files can be downloaded
# leave it at "None" to disable downloads, or set it to:
#   ftp://ftp.unibe.ch/aiub/CODE/
# to download from the "standard" server
! ionex_server  = ftp://ftp.aiub.unibe.ch/CODE/

###########################################################################
## PARAMETER SETUP
## SECTION 3: Do not update

## Configuration for long baseline pipeline (update long_baseline_pipeline_dir at top)
# ! transfer_amp_clock_sols_script    = {{ long_baseline_pipeline_dir }}/bin/transfer_amplitudes+clock+offset_toMS.py
! transfer_amp_clock_sols_script    = {{ prefactor_dir }}/scripts/transfer_gains_RMextract.py
! update_ISgains_script             = {{ long_baseline_pipeline_dir }}/bin/addISgains.py
! add_IS_script                     = {{ long_baseline_pipeline_dir }}/bin/addInternationalStations.py
! download_cats_script		    = {{ long_baseline_pipeline_dir }}/bin/download_cats.py
! closure_phase_script              = {{ long_baseline_pipeline_dir }}/bin/closure_v4.py
! skynet_script                     = {{ long_baseline_pipeline_dir }}/bin/skynet_master.py
! model_engine_script               = {{ long_baseline_pipeline_dir }}/bin/model_engine.py
! execute_circ_conv_script          = {{ long_baseline_pipeline_dir }}/bin/execute_circ_pol_conv.py
! lin2circ_script                   = {{ long_baseline_pipeline_dir }}/bin/lin2circ.py
! self_cal_and_imaging_script       = {{ long_baseline_pipeline_dir }}/bin/self_calibration_and_imaging.py
! find_best_delay_cal_script 	    = {{ long_baseline_pipeline_dir }}/bin/evaluate_potential_delay_calibrators.py
! firstnpy_file                     = {{ long_baseline_pipeline_dir }}/data/first_2008.simple.npy
! convert_ct_script		    = {{ long_baseline_pipeline_dir }}/bin/convert_clocktec_to_npy.py
! losoto_parset			    = {{ long_baseline_pipeline_dir }}/parsets/losoto.parset
! copyST_gains_script		    = {{ long_baseline_pipeline_dir }}/bin/copySTgains_toCS_h5parm.py

## Configuration for prefactor scripts (update prefactor_dir at top)
! losoto_importer       = {{ long_baseline_pipeline_dir }}/bin/losotoImporter.py
! fitamps_script        = {{ long_baseline_pipeline_dir }}/bin/amplitudes_losoto_3.py
# ! plotsols_script       = {{ prefactor_dir }}/scripts/examine_npys.py
! plotsols_script       = {{ long_baseline_pipeline_dir }}/bin/examine_npys_losoto.py
! sort_concat_script    = {{ prefactor_dir }}/scripts/sort_times_into_freqGroups.py
# script to download ionex files
! get_ion_script  = {{ prefactor_dir }}/bin/download_IONEX.py
# the prefix of the IONEX files
! ionex_prefix  = CODG
# path where the IONEX files can be stored or are already stored
! ionex_path    = {{ job_directory }}/IONEX/


##
## END CONFIGURATION

###########################################################################


##################################################################################################################
##														##
##			BEGIN PIPELINE: DO NOT UPDATE BELOW THIS LINE!						##
##														##
##################################################################################################################

# create the results directory if needed
mk_results_dir.control.kind               = plugin
mk_results_dir.control.type               = makeDirectory
mk_results_dir.control.directory          = {{ results_directory }}

# create the inspection_directory if needed
mk_inspect_dir.control.kind               = plugin
mk_inspect_dir.control.type               = makeDirectory
mk_inspect_dir.control.directory          = {{ inspection_directory }}

# create the cal_values_directory if needed
mk_cal_values_dir.control.kind               =  plugin
mk_cal_values_dir.control.type               =  makeDirectory
mk_cal_values_dir.control.directory          =  {{ cal_values_directory }}

# create a directory for the ionex files
mk_ionex_dir.control.kind		  = plugin
mk_ionex_dir.control.type		  = makeDirectory
mk_ionex_dir.control.directory		  = {{ job_directory }}/IONEX

# generate a mapfile of all the target data
createmap_target.control.kind             = plugin
createmap_target.control.type             = createMapfile
createmap_target.control.method           = mapfile_from_folder
createmap_target.control.mapfile_dir      = input.output.mapfile_dir
createmap_target.control.filename         = createmap_target.mapfile
createmap_target.control.folder           = {{ target_input_path }}
createmap_target.control.pattern          = {{ target_input_pattern }}

## at this point, prepare the solution tables, which will avoid processing subbands 
## for which no solutions are present. 

# create a mapfile of the phase solution measurement sets
createmap_ps.control.kind                            = plugin
createmap_ps.control.type                            = createMapfile
createmap_ps.control.method                          = mapfile_from_folder
createmap_ps.control.mapfile_dir                     = input.output.mapfile_dir
createmap_ps.control.filename                        = createmap_ps.mapfile
createmap_ps.control.folder                          = {{ phase_sol_input_path }}
createmap_ps.control.pattern                         = *.pre-cal.ms

# find the phase solution tables
createmap_ps_tables.control.kind		     = plugin
createmap_ps_tables.control.type		     = createMapfile
createmap_ps_tables.control.method		     = add_suffix_to_file
createmap_ps_tables.control.mapfile_in		     = createmap_ps.output.mapfile
createmap_ps_tables.control.add_suffix_to_file	     = /instrument_directionindependent
createmap_ps_tables.control.mapfile_dir		     = input.output.mapfile_dir
createmap_ps_tables.control.filename		     = createmap_ps_tables.mapfile

# make mapfile with the filenames of the results that we want
make_ps_out_mapfile.control.kind            = plugin
make_ps_out_mapfile.control.type            = makeResultsMapfile
make_ps_out_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_ps_out_mapfile.control.filename        = make_ps_out_mapfile.mapfile
make_ps_out_mapfile.control.mapfile_in      = createmap_ps.output.mapfile
make_ps_out_mapfile.control.target_dir      = {{ job_directory }}
make_ps_out_mapfile.control.make_target_dir = True
make_ps_out_mapfile.control.new_suffix      = .phase_table

# copy the phase solutions to the working directory
copy_sols.control.kind                               = recipe
copy_sols.control.type                               = executable_args
copy_sols.control.executable                         = /bin/cp
copy_sols.control.max_per_node                       = {{ num_proc_per_node }}
copy_sols.control.mapfiles_in                        = [createmap_ps_tables.output.mapfile,make_ps_out_mapfile.output.mapfile]
copy_sols.control.inputkeys                          = [source,destination]
copy_sols.control.arguments                          = [-r,source,destination]

# create a mapfile of the copied phase solution tables
createmap_pstwo.control.kind                         = plugin
createmap_pstwo.control.type                         = createMapfile
createmap_pstwo.control.method                       = mapfile_from_folder
createmap_pstwo.control.mapfile_dir                  = input.output.mapfile_dir
createmap_pstwo.control.filename                     = createmap_pstwo.mapfile
createmap_pstwo.control.folder                       = {{ job_directory }}
createmap_pstwo.control.pattern                      = *.phase_table

# match the measurement sets with the appropriate phase solutions -- this ensures
# you only process subbands with appropriate solutions
match_files.control.kind                             = plugin
match_files.control.type                             = FindCorrespondingMSnew
match_files.control.mapfile_dir                      = input.output.mapfile_dir
match_files.control.filename                         = match_files.mapfile
match_files.control.mapfile_grpd                     = createmap_pstwo.output.mapfile
match_files.control.mapfile_ms                       = createmap_target.output.mapfile

# run NDPPP on the target data
ndppp_prep_target.control.type                    = dppp
ndppp_prep_target.control.max_per_node            = {{ num_proc_per_node }}
ndppp_prep_target.control.error_tolerance         = {{ error_tolerance }}
ndppp_prep_target.argument.numthreads             = {{ max_dppp_threads }}
ndppp_prep_target.argument.msin                   = match_files.output.mapfile  
ndppp_prep_target.argument.msin.datacolumn        = DATA
ndppp_prep_target.argument.msin.baseline          = *&
ndppp_prep_target.argument.msout.datacolumn       = DATA
ndppp_prep_target.argument.msout.writefullresflag = False
ndppp_prep_target.argument.steps                  = [flag,flagamp]
ndppp_prep_target.argument.flag.type              = preflagger
ndppp_prep_target.argument.flag.baseline          = {{ flag_baselines }}
ndppp_prep_target.argument.flagamp.type           = preflagger
ndppp_prep_target.argument.flagamp.amplmin        = 1e-30
#ndppp_prep_target.argument.doflagging.type        = aoflagger
#ndppp_prep_target.argument.doflagging.strategy    = {{ lofar_directory }}/share/rfistrategies/HBAdefault

# combine all entries into one mapfile, for the download ionex script
combine_data_target_map.control.kind            =   plugin
combine_data_target_map.control.type            =   createMapfile
combine_data_target_map.control.method          =   mapfile_all_to_one
combine_data_target_map.control.mapfile_dir     =   input.output.mapfile_dir
combine_data_target_map.control.filename        =   combine_data_tar_map.mapfile
combine_data_target_map.control.mapfile_in      =   ndppp_prep_target.output.mapfile

# get ionex files once for every day that is covered by one of the input MSs
get_ion_files.control.type            = pythonplugin
get_ion_files.control.executable      = {{ get_ion_script }}
get_ion_files.control.max_per_node    =  1
get_ion_files.control.error_tolerance = {{ error_tolerance }}
get_ion_files.argument.flags          = [combine_data_target_map.output.mapfile]
get_ion_files.argument.ionex_server   = {{ ionex_server }}
get_ion_files.argument.ionex_prefix   = {{ ionex_prefix }}
get_ion_files.argument.ionexPath      = {{ ionex_path }}

# generate parmDB with the interpolated calibrator data to apply to the traget
transfer_amp_clock_sols.control.type              =  pythonplugin
transfer_amp_clock_sols.control.executable        =  {{ transfer_amp_clock_sols_script }}
transfer_amp_clock_sols.control.max_per_node      =  {{ num_proc_per_node }}
transfer_amp_clock_sols.control.error_tolerance   =  {{ error_tolerance }}
transfer_amp_clock_sols.control.mapfile_in        =  ndppp_prep_target.output.mapfile
transfer_amp_clock_sols.control.inputkey          =  indata
transfer_amp_clock_sols.argument.flags            =  [indata]
transfer_amp_clock_sols.argument.store_basename   =  {{ amp_sols_basename }}
transfer_amp_clock_sols.argument.store_directory  =  {{ transfer_amp_clock_sols_store }}
transfer_amp_clock_sols.argument.newparmdbext     =  /instrument_amp_clock_offset
transfer_amp_clock_sols.argument.ionex_server     =  {{ ionex_server }}
transfer_amp_clock_sols.argument.ionex_prefix     =  {{ ionex_prefix }}
transfer_amp_clock_sols.argument.ionexPath        =  {{ ionex_path }}

# scale international amplitudes in solutions
is_amp_gains.control.type                            = pythonplugin  
is_amp_gains.control.executable                      = {{ update_ISgains_script }}
is_amp_gains.control.mapfile_in                      = transfer_amp_clock_sols.output.transfer_parmDB.mapfile
is_amp_gains.control.inputkey                        = parmdbs
is_amp_gains.argument.parmdbfile                     = parmdbs
is_amp_gains.argument.targetms                       = ndppp_prep_target.output.mapfile

# add international stations to phase solutions
# only needs to to be done for the phase tables, which are 
# by band from prefactor
is_add_phase.control.type                            = pythonplugin  
is_add_phase.control.executable                      = {{ add_IS_script }}
is_add_phase.control.mapfile_in                      = match_files.output.ISparmdbs
is_add_phase.control.inputkey                        = tables
is_add_phase.argument.flags                          = [tables,match_files.output.mapfile]

# run NDPPP to apply the solutions to the target data
ndppp_apply_cal.control.type                         = dppp
ndppp_apply_cal.control.max_per_node                 = {{ num_proc_per_node }}
ndppp_apply_cal.control.error_tolerance              = {{ error_tolerance }}
ndppp_apply_cal.control.outputkey           	     =  
ndppp_apply_cal.control.mapfile_in                   = match_files.output.parmdbs
ndppp_apply_cal.control.inputkey                     = parmdbs
ndppp_apply_cal.argument.numthreads       	     = {{ max_dppp_threads }}
ndppp_apply_cal.argument.msin	                     = ndppp_prep_target.output.mapfile
ndppp_apply_cal.argument.msin.datacolumn             = DATA
ndppp_apply_cal.argument.msin.baseline               = *&
ndppp_apply_cal.argument.msout                       = .
ndppp_apply_cal.argument.msout.datacolumn            = CORRECTED_DATA
ndppp_apply_cal.argument.msout.writefullresflag      = False
ndppp_apply_cal.argument.steps                    = [applyclock,applygain,applybeam,applyrotate,applyphase]
ndppp_apply_cal.argument.applyclock.type          = applycal
ndppp_apply_cal.argument.applyclock.parmdb        = transfer_amp_clock_sols.output.transfer_parmDB.mapfile
ndppp_apply_cal.argument.applyclock.correction    = clock
ndppp_apply_cal.argument.applygain.type           = applycal
ndppp_apply_cal.argument.applygain.parmdb         = transfer_amp_clock_sols.output.transfer_parmDB.mapfile
ndppp_apply_cal.argument.applygain.correction     = gain
ndppp_apply_cal.argument.applygain.updateweights  = True
ndppp_apply_cal.argument.applybeam.type           = applybeam
ndppp_apply_cal.argument.applybeam.usechannelfreq = True
ndppp_apply_cal.argument.applybeam.updateweights  = True
ndppp_apply_cal.argument.applyrotate.type         = applycal
ndppp_apply_cal.argument.applyrotate.parmdb       = transfer_amp_clock_sols.output.transfer_parmDB.mapfile
ndppp_apply_cal.argument.applyrotate.correction	  = commonrotationangle
ndppp_apply_cal.argument.applyphase.type	  = applycal
ndppp_apply_cal.argument.applyphase.parmdb	  = parmdbs
ndppp_apply_cal.argument.applyphase.correction	  = gain

# download the relevant catalogues
download_cats.control.kind			= plugin
download_cats.control.type			= DownloadCats
download_cats.control.mapfile_in			= ndppp_prep_target.output.mapfile
download_cats.control.lotss_radius		= 2.
download_cats.control.lbcs_radius		= 2.
download_cats.control.bright_limit_Jy		= 5.
download_cats.control.lotss_result_file	= {{ image_cat }}
download_cats.control.delay_cals_file		= {{ delay_cat }}
download_cats.control.subtract_file 		= {{ subtract_cat }}
download_cats.control.match_tolerance		= 5.
download_cats.control.subtract_limit		= 0.5
download_cats.control.image_limit_Jy		= 0.05
download_cats.control.doDownload		= {{ do_download }}

##################################################################
#                                                               ##
#      		      DELAY CALIBRATION 	                ##
#                                                               ##
##################################################################


# do a parallel search for the best delay calibrator
do_parallel.control.type                  = pythonplugin
do_parallel.control.max_per_node          = {{ num_proc_per_node }}
do_parallel.control.executable            = {{ find_best_delay_cal_script }}
do_parallel.argument.flags                = [combine_data_target_map.output.mapfile,{{ delay_cat }}]
do_parallel.argument.ncpu                 = {{ num_proc_per_node_limit }}

# automatically find the best calibrator 
find_delay_cal.control.kind		  = plugin
find_delay_cal.control.type		  = DelayCalToMapfile
find_delay_cal.control.delaycals	  = {{ delay_cat }}
find_delay_cal.control.clphase_file	  = {{ job_directory }}/closure_phases.txt

# Initialise file with all directions
prep_dirs.control.kind                    = plugin
prep_dirs.control.type                    = TargetListToMapfile
prep_dirs.control.mapfile_dir             = input.output.mapfile_dir
prep_dirs.control.infile                  = ndppp_prep_target.output.mapfile
prep_dirs.control.filename                = prep_dirs.mapfile
prep_dirs.control.wd                      = {{ job_directory }}
prep_dirs.control.nP                      = 3   # this is the default setting
prep_dirs.control.counter                 = 0
prep_dirs.control.manual                  = True ## 
prep_dirs.control.target_file             = find_delay_cal.output.calfile

# shift, average and add up stations for tied array
dppp_phaseup.control.type                 = dppp
dppp_phaseup.control.max_per_node         = {{ num_proc_per_node }}
dppp_phaseup.control.mapfile_out          = prep_dirs.output.mapfile
dppp_phaseup.argument.msin                = ndppp_prep_target.output.mapfile
dppp_phaseup.argument.msin.datacolumn     = CORRECTED_DATA
dppp_phaseup.argument.msout.datacolumn    = DATA
dppp_phaseup.argument.msout.overwrite     = True
dppp_phaseup.argument.steps               = [shift, avg, adder, filter]
dppp_phaseup.argument.shift.type          = phaseshift
dppp_phaseup.argument.shift.phasecenter   = prep_dirs.output.coords
dppp_phaseup.argument.avg.type            = squash
dppp_phaseup.argument.avg.freqstep        = {{ cal_shift_avg_freqstep }}
dppp_phaseup.argument.avg.timestep        = {{ cal_shift_avg_timestep }}
dppp_phaseup.argument.adder.type          = stationadder
dppp_phaseup.argument.adder.stations      = {{ phaseup_command }}
dppp_phaseup.argument.filter.type         = filter
dppp_phaseup.argument.filter.baseline     = {{ filter_command }}
dppp_phaseup.argument.filter.remove       = True
dppp_phaseup.argument.numthreads          = {{ max_dppp_threads }}

# Convert to circular polarisation (in place)
make_circ.control.type                    = pythonplugin
make_circ.control.executable              = {{ execute_circ_conv_script }}
make_circ.argument.flags                  = [ dppp_phaseup.output.mapfile ]
make_circ.argument.cpath                  = {{ lin2circ_script }}
make_circ.argument.mode                   = lin2circ

# get a list of all subbands
make_concatmap.control.kind               =  plugin
make_concatmap.control.type               =  createMapfile
make_concatmap.control.method             =  mapfile_all_to_one
make_concatmap.control.mapfile_in         =  dppp_phaseup.output.mapfile
make_concatmap.control.mapfile_dir        =  input.output.mapfile_dir
make_concatmap.control.filename           =  make_concatmap.mapfile

# sort them by frequency and fill in missing subband information
sort_concatmap.control.type               = pythonplugin
sort_concatmap.control.executable         = {{ sort_concat_script }}
sort_concatmap.argument.flags             = [make_concatmap.output.mapfile]
sort_concatmap.argument.filename          = sort_concatmap
sort_concatmap.argument.mapfile_dir       = input.output.mapfile_dir
sort_concatmap.argument.target_path       = {{ job_directory }}
sort_concatmap.argument.NDPPPfill         = True
sort_concatmap.argument.stepname          = dpppconcat
sort_concatmap.argument.firstSB           = None
sort_concatmap.argument.truncateLastSBs   = False

# convert the output of sort_concatmap into usable mapfile
do_sortmap_maps.control.kind              =  plugin
do_sortmap_maps.control.type              =  mapfilenamesFromMapfiles
do_sortmap_maps.control.mapfile_groupmap  =  sort_concatmap.output.groupmapfile.mapfile
do_sortmap_maps.control.mapfile_datamap   =  sort_concatmap.output.mapfile.mapfile

# concatenate all measurement sets into one
dppp_concat.control.type                  = dppp
dppp_concat.control.max_per_node          = {{ num_proc_per_node }}
dppp_concat.control.error_tolerance       = {{ error_tolerance }}
dppp_concat.control.mapfile_out           = do_sortmap_maps.output.groupmap
dppp_concat.control.mapfiles_in           = [do_sortmap_maps.output.datamap]
dppp_concat.control.inputkey              = msin
dppp_concat.argument.msin.datacolumn      = DATA
dppp_concat.argument.msin.missingdata     = True
dppp_concat.argument.msin.orderms         = False
dppp_concat.argument.msout.datacolumn     = DATA
dppp_concat.argument.msout.writefullresflag = False
dppp_concat.argument.msout.overwrite      = True
dppp_concat.argument.steps                = []
dppp_concat.argument.numthreads           = {{ max_dppp_threads }}

# generate the calibrator model with skynet
delay_cal_model.control.type		  = pythonplugin
delay_cal_model.control.executable	  = {{ skynet_script }}
delay_cal_model.control.mapfile_in	  = do_sortmap_maps.output.groupmap
delay_cal_model.control.inputkey	  = msin
delay_cal_model.argument.flags		  = [msin]
delay_cal_model.argument.self_cal_script  = {{ self_cal_and_imaging_script }}
delay_cal_model.argument.mode		  = 2
delay_cal_model.argument.closure_tels	  = {{ closure_phase_stations }}
delay_cal_model.argument.cthr		  = 1.6
delay_cal_model.argument.model_only	  = 1
delay_cal_model.argument.firstnpy	  = {{ firstnpy_file }}
delay_cal_model.argument.delayCalFile	  = {{ job_directory }}/primary_delay_calibrator.csv

# generate mapfile with the sourceDB names to be used in the gsmcal steps
delay_cal_model_map.control.kind               =  plugin
delay_cal_model_map.control.type               =  createMapfile
delay_cal_model_map.control.method             =  add_suffix_to_file
delay_cal_model_map.control.mapfile_in         =  dppp_concat.output.mapfile
delay_cal_model_map.control.add_suffix_to_file =  /sky
delay_cal_model_map.control.mapfile_dir        =  input.output.mapfile_dir
delay_cal_model_map.control.filename           =  do_sortmap_maps.output.groupmap

# generate gain solutions for clock/tec separation -- need also to apply amplitude corrections
calib_cal.control.type                    = dppp
calib_cal.control.max_per_node            = {{ num_proc_per_node_limit }}
calib_cal.control.error_tolerance         = {{ error_tolerance }}
calib_cal.argument.numthreads             = {{ max_dppp_threads }}
calib_cal.argument.msin                   = dppp_concat.output.mapfile
calib_cal.argument.msin.datacolumn        = DATA
calib_cal.argument.msin.baseline          = *&
calib_cal.argument.msout.datacolumn       = DATA
calib_cal.argument.steps                  = [gaincal]
calib_cal.argument.gaincal.type           = gaincal
calib_cal.argument.gaincal.caltype        = diagonal
calib_cal.argument.gaincal.parmdb         = {{ job_directory }}/delay_cal.h5
calib_cal.argument.gaincal.applysolution  = False
calib_cal.argument.gaincal.nchan          = 2
calib_cal.argument.gaincal.solint	  = 2
calib_cal.argument.gaincal.usebeammodel   = False
calib_cal.argument.gaincal.sourcedb       = delay_cal_model_map.output.mapfile


# make a losoto parset
make_losoto.control.kind                              =   plugin
make_losoto.control.type                              =   makeLosotoParset
make_losoto.control.steps                             =   [plotA1,flag,flagextend,plotA2,merge,plotP3,plotPd,plotAi3,duplicatePbkp,ct3,plotClock,plotTEC,plotTEC3,residuals,plotPr,plotPr3]
make_losoto.control.filename                          =   input.output.job_directory/losoto.parset
make_losoto.control.global.ncpu                       =   {{ num_proc_per_node }}
make_losoto.control.plotA1.operation                 =   PLOT
make_losoto.control.plotA1.soltab                    =   sol000/amplitude000
make_losoto.control.plotA1.axesInPlot                =   [time,freq]
make_losoto.control.plotA1.axisInTable               =   ant
make_losoto.control.plotA1.plotFlag                  =   True
make_losoto.control.plotA1.prefix                    =   {{ inspection_directory }}/delay_cal_ampBFlag_
make_losoto.control.flag.operation                   =   FLAG
make_losoto.control.flag.soltab                      =   sol000/amplitude000
make_losoto.control.flag.axesToFlag                  =   [time]
make_losoto.control.flag.order                       =   [100]
make_losoto.control.flag.maxCycles                   =   1
make_losoto.control.flag.maxRms                      =   5
make_losoto.control.flag.replce                      =   False
make_losoto.control.flag.preFlagZeros                =   False
make_losoto.control.flag.mode                        =   smooth
make_losoto.control.flagextend.operation             =   FLAGEXTEND
make_losoto.control.flagextend.soltab                =   sol000/amplitude000
make_losoto.control.flagextend.axesToExt             =   [freq,time]
make_losoto.control.flagextend.size                  =   [50,100]
make_losoto.control.flagextend.percent               =   50
make_losoto.control.flagextend.maxCycles             =   3
make_losoto.control.plotA2.operation                 =   PLOT
make_losoto.control.plotA2.soltab                    =   sol000/amplitude000
make_losoto.control.plotA2.axesInPlot                =   [time,freq]
make_losoto.control.plotA2.axisInTable               =   ant
make_losoto.control.plotA2.plotFlag                  =   True
make_losoto.control.plotA2.prefix                    =   {{ inspection_directory }}/delay_cal_ampAFlag_
make_losoto.control.merge.operation                  =   REWEIGHT
make_losoto.control.merge.mode                       =   copy
make_losoto.control.merge.soltab                     =   sol000/phase000
make_losoto.control.merge.soltabImport               =   amplitude000
make_losoto.control.plotP3.operation                 =   PLOT
make_losoto.control.plotP3.soltab                    =   sol000/phase000
make_losoto.control.plotP3.axesInPlot                =   [time,freq]
make_losoto.control.plotP3.axisInTable               =   ant
make_losoto.control.plotP3.plotFlag                  =   True
make_losoto.control.plotP3.prefix                    =   {{ inspection_directory }}/delay_cal_ph_
make_losoto.control.plotP3.refAnt                    =   ST001
make_losoto.control.plotP3.minmax                    =   [-3.14,3.14]
make_losoto.control.plotPd.operation                 =   PLOT
make_losoto.control.plotPd.soltab                    =   sol000/phase000
make_losoto.control.plotPd.axesInPlot                =   [time,freq]
make_losoto.control.plotPd.axisInTable               =   ant
make_losoto.control.plotPd.axisDiff                  =   pol
make_losoto.control.plotPd.plotFlag                  =   True
make_losoto.control.plotPd.prefix                    =   {{ inspection_directory }}/delay_cal_ph_poldif
make_losoto.control.plotPd.refAnt                    =   ST001
make_losoto.control.plotPd.minmax                    =   [-3.14,3.14]
make_losoto.control.plotAi3.operation                =   PLOT
make_losoto.control.plotAi3.soltab                   =   sol000/amplitude000
make_losoto.control.plotAi3.axesInPlot               =   [time,freq]
make_losoto.control.plotAi3.axisInTable              =   ant
make_losoto.control.plotAi3.plotFlag                 =   True
make_losoto.control.plotAi3.prefix                   =   {{ inspection_directory }}/delay_cal_amp_
make_losoto.control.duplicatePbkp.operation          =   DUPLICATE
make_losoto.control.duplicatePbkp.soltab             =   sol000/phase000
make_losoto.control.duplicatePbkp.soltabOut          =   phaseOrig000
make_losoto.control.ct.operation                     =   CLOCKTEC
make_losoto.control.ct.soltab                        =   sol000/phase000
make_losoto.control.ct.CombinePol                    =   True
make_losoto.control.ct.FlagBadChannels               =   False
make_losoto.control.ct.Fit3rdOrder                   =   False
make_losoto.control.ct.Circular                      =   True
make_losoto.control.ct3.operation                    =   CLOCKTEC
make_losoto.control.ct3.soltab                       =   sol000/phase000
make_losoto.control.ct3.CombinePol                   =   True
make_losoto.control.ct3.FlagBadChannels              =   False
make_losoto.control.ct3.Fit3rdOrder                  =   True
make_losoto.control.ct3.Circular                     =   True
make_losoto.control.plotClock.operation              =   PLOT
make_losoto.control.plotClock.soltab                 =   sol000/clock000
make_losoto.control.plotClock.axesInPlot             =   [time]
make_losoto.control.plotClock.axisInTable            =   ant
make_losoto.control.plotClock.prefix                 =   {{ inspection_directory }}/delay_cal_clock
make_losoto.control.plotClock.plotFlag               =   False
make_losoto.control.plotClock.refAnt                 =   ST001
make_losoto.control.plotTEC.operation                =   PLOT
make_losoto.control.plotTEC.soltab                   =   sol000/tec000
make_losoto.control.plotTEC.axesInPlot               =   [time]
make_losoto.control.plotTEC.axisInTable              =   ant
make_losoto.control.plotTEC.prefix                   =   {{ inspection_directory }}/delay_cal_tec
make_losoto.control.plotTEC.plotFlag                 =   False
make_losoto.control.plotTEC.refAnt                   =   ST001
make_losoto.control.plotTEC3.operation               =   PLOT
make_losoto.control.plotTEC3.soltab                  =   sol000/tec3rd000
make_losoto.control.plotTEC3.axesInPlot              =   [time]
make_losoto.control.plotTEC3.axisInTable             =   ant
make_losoto.control.plotTEC3.prefix                  =   {{ inspection_directory }}/delay_cal_tec3rd
make_losoto.control.plotTEC3.plotFlag                =   False
make_losoto.control.plotTEC3.refAnt                  =   ST001
make_losoto.control.residuals.operation              =   RESIDUALS
make_losoto.control.residuals.soltab                 =   sol000/phase000
make_losoto.control.residuals.soltabsToSub           =   [tec000,clock000]
make_losoto.control.residuals3.operation             =   RESIDUALS
make_losoto.control.residuals3.soltab                =   sol000/phase000
make_losoto.control.residuals3.soltabsToSub          =   [tec000,clock000,tec3rd000] 
make_losoto.control.plotPr.operation                 =   PLOT
make_losoto.control.plotPr.soltab                    =   sol000/phase000
make_losoto.control.plotPr.axesInPlot                =   [time,freq]
make_losoto.control.plotPr.axisInTable               =   ant
make_losoto.control.plotPr.axisDiff                  =   pol
make_losoto.control.plotPr.plotFlag                  =   True
make_losoto.control.plotPr.prefix                    =   {{ inspection_directory }}/delay_cal_ph_poldiff-res_
make_losoto.control.plotPr.refAnt                    =   ST001
make_losoto.control.plotPr.minmax                    =   [-3.14,3.14]
make_losoto.control.plotPr3.operation                =   PLOT
make_losoto.control.plotPr3.soltab                   =   sol000/phase000
make_losoto.control.plotPr3.axesInPlot               =   [time,freq]
make_losoto.control.plotPr3.axisInTable              =   ant
make_losoto.control.plotPr3.plotFlag                 =   True
make_losoto.control.plotPr3.prefix                   =   {{ inspection_directory }}/delay_cal_ph3-res_
make_losoto.control.plotPr3.refAnt                   =   ST001
make_losoto.control.plotPr3.minmax                   =   [-3.14,3.14]

# do losoto clock/tec fitting to get the nice plots
process_losoto.control.kind                          =  recipe
process_losoto.control.type                          =  executable_args
process_losoto.control.executable                    =  {{ losoto_executable }}
process_losoto.control.max_per_node		     =  {{ num_proc_per_node }}
process_losoto.argument.flags                        =  [{{ job_directory }}/delay_cal.h5, {{ job_directory }}/losoto.parset]

# get a list of all subbands
make_dppp_prep_map.control.kind                      =  plugin
make_dppp_prep_map.control.type                      =  createMapfile
make_dppp_prep_map.control.method                    =  mapfile_all_to_one
make_dppp_prep_map.control.mapfile_in                =  ndppp_prep_target.output.mapfile
make_dppp_prep_map.control.mapfile_dir               =  input.output.mapfile_dir
make_dppp_prep_map.control.filename                  =  make_dppp_prep_map.mapfile

# in delay cal parmdb, copy ST values to CS values
copyST_gains.control.kind			     =   recipe
copyST_gains.control.type                            =   executable_args
copyST_gains.control.executable                      =   {{ copyST_gains_script }}
copyST_gains.argument.flags                          =   [{{ job_directory }}/delay_cal.h5,make_dppp_prep_map.output.mapfile]
copyST_gains.argument.restrictToCS                   =   True

# Apply the gain solutions directly to the data -- no need to remove time dependence
ndppp_apply_delay.control.type                           =   dppp
ndppp_apply_delay.control.inplace                        =   True
ndppp_apply_delay.control.max_per_node                   =   {{ num_proc_per_node }}
ndppp_apply_delay.control.error_tolerance                =   {{ error_tolerance }}
ndppp_apply_delay.control.outputkey                      =
ndppp_apply_delay.control.mapfiles_in                    =   [ndppp_prep_target.output.mapfile,match_files.output.parmdbs,transfer_amp_clock_sols.output.transfer_parmDB.mapfile]
ndppp_apply_delay.control.inputkeys                      =   [inputms,parmdbs,ampclockparmdb]
ndppp_apply_delay.argument.numthreads                    =   {{ max_dppp_threads }}
ndppp_apply_delay.argument.msin                          =   inputms
ndppp_apply_delay.argument.msin.datacolumn               =   DATA
ndppp_apply_delay.argument.msin.baseline                 =   *&
ndppp_apply_delay.argument.msout                         =   .
ndppp_apply_delay.argument.msout.datacolumn              =   CORRECTED_DATA
ndppp_apply_delay.argument.msout.writefullresflag        =   False
ndppp_apply_delay.argument.steps                         =   [applyclock,applygain,applybeam,applyrotate,applyphase,applydelayamp,applydelayclock,applydelayTEC]
ndppp_apply_delay.argument.applyclock.type               =   applycal
ndppp_apply_delay.argument.applyclock.parmdb             =   ampclockparmdb
ndppp_apply_delay.argument.applyclock.correction         =   clock
ndppp_apply_delay.argument.applygain.type                =   applycal
ndppp_apply_delay.argument.applygain.parmdb              =   ampclockparmdb
ndppp_apply_delay.argument.applygain.correction          =   gain
ndppp_apply_delay.argument.applygain.updateweights       =   True
ndppp_apply_delay.argument.applybeam.type                =   applybeam
ndppp_apply_delay.argument.applybeam.usechannelfreq      =   True
ndppp_apply_delay.argument.applybeam.updateweights       =   True
ndppp_apply_delay.argument.applyrotate.type              =   applycal
ndppp_apply_delay.argument.applyrotate.parmdb            =   ampclockparmdb
ndppp_apply_delay.argument.applyrotate.correction        =   commonrotationangle
ndppp_apply_delay.argument.applyphase.type               =   applycal
ndppp_apply_delay.argument.applyphase.parmdb             =   parmdbs
ndppp_apply_delay.argument.applyphase.correction         =   gain
ndppp_apply_delay.argument.applydelayamp.type            =   applycal
ndppp_apply_delay.argument.applydelayamp.parmdb          =   {{ job_directory }}/delay_cal.h5
ndppp_apply_delay.argument.applydelayamp.correction      =   amplitude000
ndppp_apply_delay.argument.applydelayamp.solset          =   sol001
ndppp_apply_delay.argument.applydelayamp.updateweights   =   false
ndppp_apply_delay.argument.applydelayclock.type          =   applycal
ndppp_apply_delay.argument.applydelayclock.parmdb        =   {{ job_directory }}/delay_cal.h5
ndppp_apply_delay.argument.applydelayclock.correction    =   clock000
ndppp_apply_delay.argument.applydelayclock.solset        =   sol001
ndppp_apply_delay.argument.applydelayclock.updateweights =   false
ndppp_apply_delay.argument.applydelayTEC.type            =   applycal
ndppp_apply_delay.argument.applydelayTEC.parmdb          =   {{ job_directory }}/delay_cal.h5
ndppp_apply_delay.argument.applydelayTEC.correction      =   tec000
ndppp_apply_delay.argument.applydelayTEC.solset          =   sol001
ndppp_apply_delay.argument.applydelayTEC.updateweights   =   false

# copy the LoSoTo file to the inspection_directory
copy_h5imp_cal.control.kind               =  recipe
copy_h5imp_cal.control.type               =  executable_args
copy_h5imp_cal.control.executable         =  /bin/cp
copy_h5imp_cal.control.arguments          =  [{{ job_directory }}/delay_cal.h5, {{ cal_values_directory }}]


## AT THIS POINT, PHASE ONLY SOLUTIONS NEED TO BE FOUND FOR TIER 1 CALIBRATORS.
## THEN THOSE CALIBRATORS SHOULD BE SUBTRACTED.
## THEN PHASE ONLY SOLUTIONS FOR TIER 2 CALIBRATORS
## (AND THEN TIER 3?)
## THEN LOOP2 SHOULD BE RUN.


##################################################################
#                                                               ##
#                   END OF PIPELINE	                        ##
# 		                                                ##
##################################################################

