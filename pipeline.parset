#########################################################
## LOFAR long baseline calibration pipeline parset     ##
#########################################################
# Please read the instructions and report bugs on: https://github.com/varenius/long_baseline_pipeline/tree/master/surveys_processing/lofar_lb_gpipeline

## STEPS TO RUN#
pipeline.steps = [mk_results_dir, mk_calresults_dir, mk_inspect_dir, createmap_target, createmap_ps, createmap_ps_tables, make_ps_out_mapfile, copy_sols, createmap_pstwo, match_files, ndppp_prep_target, transfer_amp_clock_sols, is_amp_gains, is_add_phase, map_transfer_amp_clock_sols, ndppp_apply_cal, get_lbcs_catalogue, calibrator_loop1, createmap_plots, destmap_plots, cp_closure_phase_png, closure_phase_file, find_delay_cal, delay_cal_model, delay_cal_model_map, calib_cal, h5imp_cal, copy_h5imp_cal, fitclock, plots, createmap_cal_pngs, copy_cal_pngs, createmap_cal_txts, copy_cal_txts, mk_cal_values_dir, createmap_cal_npys, copy_cal_npys, transfer_delay_sols, ndppp_apply_delay ]
## the step 'ampl' needs to be inserted after 'fitclock' -- it won't work with less than 20 subbands, so i've removed it for testing purposes.
#createmap_plots, cp_closure_phase_png, get_imaging_catalogue, imaging_loop ]

###########################################################################
## PARAMETER SETUP
## SECTION 1: things that absolutely need to be configured

## global information
! base_directory 		        = /data/lofar/morabito/xmm_lss/L424611
! job_directory		 	        = {{ base_directory }}/pipeline/ ## must match name of parset or config file
! long_baseline_pipeline_dir 		= /home/morabito/software/long_baseline_pipeline
! prefactor_dir			        = /home/morabito/software/prefactor
! losoto_executable			= /home/morabito/software/losoto/bin/losoto

## target data information
! target_input_path             = /car-data/wwilliams/lofar_xmmlss/datastore/L424611/
! target_input_pattern          = L424611_SB*.MS

## Prefactor solution information
! transfer_amp_clock_sols_store = /data/lofar/morabito/xmm_lss/L424607/results/ ## directory with amplitude and clock solutions of prefactor (*.npy files)
! amp_sols_basename             = caldata_transfer
! phase_sol_input_path          = /data/lofar/morabito/xmm_lss/L424611/prefactor/phase_solutions ## directory with direction-independent phase solutions of the target field

## Calibrator catalogue
! calibrator_catalogue 		= /data/lofar/morabito/xmm_lss/L424611/lbcs_catalogue.csv
! use_calibrator_catalogue      = False ## True = download from LBCS if it doesn't exist, else use existing. False = do not download, stop if file doesn't exist. Force = delete existing and download

## Target catalogue
! target_catalogue              = /data/lofar/morabito/xmm_lss/L424611/lotss_catalogue.csv
! use_target_catalogue          = False ## same behaviour as use_calibrator_catalogue, but uses LoTSS catalogue instead, picking only unresolved sources

## Averaging parameters
! cal_shift_avg_timestep        = 8    ## Calibrator time averaging: output should be 8 seconds
! cal_shift_avg_freqstep        = 8    ## Calibrator freq averaging: output should be 2 channels per subband
! tgt_shift_avg_timestep        = 16   ## Target time averaging: output should be 16 seconds
! tgt_shift_avg_freqstep        = 16   ## Target freq averaging: output should be 1 channel per subband

## Stations to flag
! flag_baselines 		= [] ## for HBA data before October 2015, should set to: [ CS013HBA* ]

###########################################################################
## PARAMETER SETUP
## SECTION 2: things that are probably fine as is, but should be checked

## Output directories
! results_directory             = {{ base_directory }}/results
! calibrator_results_directory  = {{ results_directory }}/calibrators/
! inspection_directory          = {{ results_directory }}/inspection/
! cal_values_directory          = {{ results_directory }}/delay_cal_results/

## Station combination
! phaseup_command               = {ST001:'CS*'} ## 'CS*' for all core stations (or select stations you want to use)
! filter_command                = '!CS*&*'      ## remove the core stations after combination

## Closure phase stations
! closure_phase_stations        = 'DE601;DE605;ST001' ## list of three stations separated by ;
! closure_phase_file            = {{ job_directory }}/closure_phases.txt ## pipeline expects this location - do not change

## Runtime setup -- will depend on your computing cluster
! num_proc_per_node        	= 8    ## number of processes to use per step per node
! num_proc_per_node_limit  	= 4	## number of processes to use per step per node for tasks with high i/o (dppp or cp) or memory (eg calibration)
! max_dppp_threads          	= 2	## number of threads per process for NDPPP
! error_tolerance               = False ## False = stop if any subband fails, True = keep going

###########################################################################
## PARAMETER SETUP
## SECTION 3: Do not update

## Configuration for long baseline pipeline (update long_baseline_pipeline_dir at top)
! transfer_amp_clock_sols_script    = {{ long_baseline_pipeline_dir }}/bin/transfer_amplitudes+clock+offset_toMS.py
! update_ISgains_script             = {{ long_baseline_pipeline_dir }}/bin/updateISGains.py
! add_IS_script                     = {{ long_baseline_pipeline_dir }}/bin/addInternationalStations.py
! download_lbcs_script              = {{ long_baseline_pipeline_dir }}/bin/download_lbcs_catalogue.py
! closure_phase_script              = {{ long_baseline_pipeline_dir }}/bin/closure_v2.py
! skynet_script                     = {{ long_baseline_pipeline_dir }}/bin/skynet_master.py
! model_engine_script               = {{ long_baseline_pipeline_dir }}/bin/model_engine.py
! execute_circ_conv_script          = {{ long_baseline_pipeline_dir }}/bin/execute_circ_pol_conv.py
! lin2circ_script                   = {{ long_baseline_pipeline_dir }}/bin/lin2circ.py
! download_lotss_script             = {{ long_baseline_pipeline_dir }}/bin/download_lotss_catalogue.py
! self_cal_and_imaging_script       = {{ long_baseline_pipeline_dir }}/bin/self_calibration_and_imaging.py
! transfer_delay_sols_script        = {{ long_baseline_pipeline_dir }}/bin/transfer_clock+tec_toMS.py
! delay_cal_parset                  = {{ long_baseline_pipeline_dir }}/parsets/delaycalib.parset
! firstnpy_file                     = {{ long_baseline_pipeline_dir }}/data/first_2008.simple.npy

## Configuration for prefactor scripts (update prefactor_dir at top)
! losoto_importer       = {{ prefactor_dir }}/scripts/losotoImporter.py
! fitclock_script       = {{ prefactor_dir }}/scripts/fit_clocktec_initialguess_losoto.py
! fitamps_script        = {{ prefactor_dir }}/scripts/amplitudes_losoto_3.py
! plotsols_script       = {{ prefactor_dir }}/scripts/examine_npys.py
! sort_concat_script    = {{ prefactor_dir }}/scripts/sort_times_into_freqGroups.py

##
## END CONFIGURATION
###########################################################################


##################################################################################################################
##														##
##			BEGIN PIPELINE: DO NOT UPDATE BELOW THIS LINE!						##
##														##
##################################################################################################################

# create the results directory if needed
mk_results_dir.control.kind               = plugin
mk_results_dir.control.type               = makeDirectory
mk_results_dir.control.directory          = {{ results_directory }}

# create the calibrator results directory
mk_calresults_dir.control.kind		  = plugin
mk_calresults_dir.control.type		  = makeDirectory
mk_calresults_dir.control.directory	  = {{ calibrator_results_directory }}

# create the inspection_directory if needed
mk_inspect_dir.control.kind               = plugin
mk_inspect_dir.control.type               = makeDirectory
mk_inspect_dir.control.directory          = {{ inspection_directory }}

# generate a mapfile of all the target data
createmap_target.control.kind             = plugin
createmap_target.control.type             = createMapfile
createmap_target.control.method           = mapfile_from_folder
createmap_target.control.mapfile_dir      = input.output.mapfile_dir
createmap_target.control.filename         = createmap_target.mapfile
createmap_target.control.folder           = {{ target_input_path }}
createmap_target.control.pattern          = {{ target_input_pattern }}

## at this point, prepare the solution tables, which will avoid processing subbands 
## for which no solutions are present. 

# create a mapfile of the phase solution measurement sets
createmap_ps.control.kind                            = plugin
createmap_ps.control.type                            = createMapfile
createmap_ps.control.method                          = mapfile_from_folder
createmap_ps.control.mapfile_dir                     = input.output.mapfile_dir
createmap_ps.control.filename                        = createmap_ps.mapfile
createmap_ps.control.folder                          = {{ phase_sol_input_path }}
createmap_ps.control.pattern                         = *.pre-cal.ms

# find the phase solution tables
createmap_ps_tables.control.kind		     = plugin
createmap_ps_tables.control.type		     = createMapfile
createmap_ps_tables.control.method		     = add_suffix_to_file
createmap_ps_tables.control.mapfile_in		     = createmap_ps.output.mapfile
createmap_ps_tables.control.add_suffix_to_file	     = /instrument_directionindependent
createmap_ps_tables.control.mapfile_dir		     = input.output.mapfile_dir
createmap_ps_tables.control.filename		     = createmap_ps_tables.mapfile

# make mapfile with the filenames of the results that we want
make_ps_out_mapfile.control.kind            = plugin
make_ps_out_mapfile.control.type            = makeResultsMapfile
make_ps_out_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_ps_out_mapfile.control.filename        = make_ps_out_mapfile.mapfile
make_ps_out_mapfile.control.mapfile_in      = createmap_ps.output.mapfile
make_ps_out_mapfile.control.target_dir      = {{ job_directory }}
make_ps_out_mapfile.control.make_target_dir = True
make_ps_out_mapfile.control.new_suffix      = .phase_table

# copy the phase solutions to the working directory
copy_sols.control.kind                               = recipe
copy_sols.control.type                               = executable_args
copy_sols.control.executable                         = /bin/cp
copy_sols.control.max_per_node                       = {{ num_proc_per_node }}
copy_sols.control.mapfiles_in                        = [createmap_ps_tables.output.mapfile,make_ps_out_mapfile.output.mapfile]
copy_sols.control.inputkeys                          = [source,destination]
copy_sols.control.arguments                          = [-r,source,destination]

# create a mapfile of the copied phase solution tables
createmap_pstwo.control.kind                         = plugin
createmap_pstwo.control.type                         = createMapfile
createmap_pstwo.control.method                       = mapfile_from_folder
createmap_pstwo.control.mapfile_dir                  = input.output.mapfile_dir
createmap_pstwo.control.filename                     = createmap_pstwo.mapfile
createmap_pstwo.control.folder                       = {{ job_directory }}
createmap_pstwo.control.pattern                      = *.phase_table

# match the measurement sets with the appropriate phase solutions -- this ensures
# you only process subbands with appropriate solutions
match_files.control.kind                             = plugin
match_files.control.type                             = FindCorrespondingMSnew
match_files.control.mapfile_dir                      = input.output.mapfile_dir
match_files.control.filename                         = match_files.mapfile
match_files.control.mapfile_grpd                     = createmap_pstwo.output.mapfile
match_files.control.mapfile_ms                       = createmap_target.output.mapfile

# run NDPPP on the target data
ndppp_prep_target.control.type                    = dppp
ndppp_prep_target.control.max_per_node            = {{ num_proc_per_node_limit }}
ndppp_prep_target.control.error_tolerance         = {{ error_tolerance }}
ndppp_prep_target.argument.numthreads             = {{ max_dppp_threads }}
ndppp_prep_target.argument.msin                   = match_files.output.mapfile  
ndppp_prep_target.argument.msin.datacolumn        = DATA
ndppp_prep_target.argument.msin.baseline          = *&
ndppp_prep_target.argument.msout.datacolumn       = DATA
ndppp_prep_target.argument.msout.writefullresflag = False
ndppp_prep_target.argument.steps                  = [flag,flagamp]
ndppp_prep_target.argument.flag.type              = preflagger
ndppp_prep_target.argument.flag.baseline          = {{ flag_baselines }}
ndppp_prep_target.argument.flagamp.type           = preflagger
ndppp_prep_target.argument.flagamp.amplmin        = 1e-30
#ndppp_prep_target.argument.doflagging.type        = aoflagger
#ndppp_prep_target.argument.doflagging.strategy    = {{ lofar_directory }}/share/rfistrategies/HBAdefault

# create a new parmdb for transferring amplitude and clock solutions
transfer_amp_clock_sols.control.type                 = pythonplugin  
transfer_amp_clock_sols.control.executable           = {{ transfer_amp_clock_sols_script }}
transfer_amp_clock_sols.argument.msname              = ndppp_prep_target.output.mapfile
transfer_amp_clock_sols.argument.npdir               = {{ transfer_amp_clock_sols_store }}
transfer_amp_clock_sols.store_basename               = {{ amp_sols_basename }}
transfer_amp_clock_sols.argument.output              = outputkey


# scale international amplitudes in solutions
is_amp_gains.control.type                            = pythonplugin  
is_amp_gains.control.executable                      = {{ update_ISgains_script }}
is_amp_gains.argument.flags                          = [ transfer_amp_clock_sols.output.mapfile ]

# add international stations to phase solutions
# only needs to to be done for the phase tables, which are 
# by band from prefactor
is_add_phase.control.type                            = pythonplugin  
is_add_phase.control.executable                      = {{ add_IS_script }}
is_add_phase.control.mapfile_in                      = match_files.output.ISparmdbs
is_add_phase.control.inputkey                        = tables
is_add_phase.argument.flags                          = [tables,match_files.output.mapfile]

# make a list of the correct transfer_amp_clock_sols files
map_transfer_amp_clock_sols.control.kind	     = plugin
map_transfer_amp_clock_sols.control.type	     = makeResultsMapfile
map_transfer_amp_clock_sols.control.mapfile_dir      = input.output.mapfile_dir
map_transfer_amp_clock_sols.control.filename         = map_transfer_amp_clock_sols.mapfile
map_transfer_amp_clock_sols.control.mapfile_in       = ndppp_prep_target.output.mapfile
map_transfer_amp_clock_sols.control.target_dir       = {{ job_directory }}
map_transfer_amp_clock_sols.control.new_suffix       = .transfer_amp_clock_sols

# run NDPPP to apply the solutions to the target data
ndppp_apply_cal.control.type                         = dppp
ndppp_apply_cal.control.max_per_node                 = {{ num_proc_per_node }}
ndppp_apply_cal.control.error_tolerance              = {{ error_tolerance }}
ndppp_apply_cal.control.outputkey           	     =  
ndppp_apply_cal.control.mapfile_in                   = match_files.output.parmdbs
ndppp_apply_cal.control.inputkey                     = parmdbs
ndppp_apply_cal.argument.numthreads       	     = {{ max_dppp_threads }}
ndppp_apply_cal.argument.msin	                     = ndppp_prep_target.output.mapfile
ndppp_apply_cal.argument.msin.datacolumn             = DATA
ndppp_apply_cal.argument.msin.baseline               = *&
ndppp_apply_cal.argument.msout                       = .
ndppp_apply_cal.argument.msout.datacolumn            = CORRECTED_DATA
ndppp_apply_cal.argument.msout.writefullresflag      = False
ndppp_apply_cal.argument.steps                       = [applyAmp, applyClock, ApplyPhase, applytheBeam]
ndppp_apply_cal.argument.applyAmp.type               = applycal
ndppp_apply_cal.argument.applyAmp.parmdb             = map_transfer_amp_clock_sols.output.mapfile
ndppp_apply_cal.argument.applyAmp.correction         = gain
ndppp_apply_cal.argument.applyAmp.updateweights      = false
ndppp_apply_cal.argument.applyClock.type             = applycal
ndppp_apply_cal.argument.applyClock.parmdb           = map_transfer_amp_clock_sols.output.mapfile
ndppp_apply_cal.argument.applyClock.correction       = clock
ndppp_apply_cal.argument.applyClock.updateweights    = false
ndppp_apply_cal.argument.ApplyPhase.type             = applycal
ndppp_apply_cal.argument.ApplyPhase.parmdb           = parmdbs
ndppp_apply_cal.argument.ApplyPhase.correction       = gain
ndppp_apply_cal.argument.ApplyPhase.updateweights    = false
ndppp_apply_cal.argument.applytheBeam.type           = applybeam
ndppp_apply_cal.argument.applytheBeam.usechannelfreq = true
ndppp_apply_cal.argument.applytheBeam.invert         = true
ndppp_apply_cal.argument.applytheBeam.beammode       = default


##################################################################
#								##
#	CALIBRATOR LOOP 1: FIND THE BEST CALIBRATOR		##
#								##
##################################################################


# use LBCS to get a catalogue of potential calibrators, or use existing catalogue
get_lbcs_catalogue.control.type         	= pythonplugin
get_lbcs_catalogue.control.executable           = {{ download_lbcs_script }}
get_lbcs_catalogue.argument.flags               = [ndppp_prep_target.output.mapfile]
get_lbcs_catalogue.argument.ResultsFile         = {{ calibrator_catalogue }}
get_lbcs_catalogue.argument.DoDownload          = {{ use_calibrator_catalogue }}
get_lbcs_catalogue.argument.Radius              = 1.5

# Loop through the target phase calibrator canditates
calibrator_loop1.control.kind                    = loop
calibrator_loop1.control.type                    = conditional
calibrator_loop1.control.loopcount               = 100
calibrator_loop1.control.loopsteps               = [ prep_dirs, dppp_phaseup, make_circ, make_concatmap, sort_concatmap, do_sortmap_maps, dppp_concat, closure_phase, delete_intermediate_files ]

# Initialise file with all directions
prep_dirs.control.kind                    = plugin
prep_dirs.control.type                    = TargetListToMapfileX
prep_dirs.control.mapfile_dir             = input.output.mapfile_dir
prep_dirs.control.infile                  = ndppp_prep_target.output.mapfile
prep_dirs.control.filename                = prep_dirs.mapfile
prep_dirs.control.wd                      = {{ job_directory }}
prep_dirs.control.nP                      = 3	# this is the default setting
prep_dirs.control.counter                 = calibrator_loop1.output.counter
prep_dirs.control.manual		  = True ## use the catalogue specified in get_lbcs_catalogue step
prep_dirs.control.target_file             = {{ calibrator_catalogue }}

# shift, average and add up stations for tied array
dppp_phaseup.control.type                 = dppp
dppp_phaseup.control.max_per_node         = {{ num_proc_per_node }}
dppp_phaseup.control.mapfile_out          = prep_dirs.output.mapfile 
dppp_phaseup.argument.msin                = ndppp_prep_target.output.mapfile
dppp_phaseup.argument.msin.datacolumn     = CORRECTED_DATA
dppp_phaseup.argument.msout.datacolumn    = DATA
dppp_phaseup.argument.msout.overwrite     = True
dppp_phaseup.argument.steps               = [shift, avg, adder, filter]
dppp_phaseup.argument.shift.type          = phaseshift
dppp_phaseup.argument.shift.phasecenter   = prep_dirs.output.cords
dppp_phaseup.argument.avg.type            = squash
dppp_phaseup.argument.avg.freqstep        = {{ cal_shift_avg_freqstep }}
dppp_phaseup.argument.avg.timestep        = {{ cal_shift_avg_timestep }}
dppp_phaseup.argument.adder.type          = stationadder
dppp_phaseup.argument.adder.stations      = {{ phaseup_command }}
dppp_phaseup.argument.filter.type         = filter
dppp_phaseup.argument.filter.baseline     = {{ filter_command }}
dppp_phaseup.argument.filter.remove       = True
dppp_phaseup.argument.numthreads	  = {{ max_dppp_threads }} 

# Convert to circular polarisation (in place)
make_circ.control.type                    = pythonplugin  
make_circ.control.executable              = {{ execute_circ_conv_script }}
make_circ.argument.flags                  = [ dppp_phaseup.output.mapfile ]
make_circ.argument.cpath                  = {{ lin2circ_script }}
make_circ.argument.mode                   = lin2circ

# get a list of all subbands
make_concatmap.control.kind               =  plugin
make_concatmap.control.type               =  createMapfile
make_concatmap.control.method             =  mapfile_all_to_one
make_concatmap.control.mapfile_in         =  dppp_phaseup.output.mapfile
make_concatmap.control.mapfile_dir        =  input.output.mapfile_dir
make_concatmap.control.filename           =  make_concatmap.mapfile

# sort them by frequency and fill in missing subband information
sort_concatmap.control.type               = pythonplugin  
sort_concatmap.control.executable         = {{ sort_concat_script }}
sort_concatmap.argument.flags             = [make_concatmap.output.mapfile]
sort_concatmap.argument.filename          = sort_concatmap
sort_concatmap.argument.mapfile_dir       = input.output.mapfile_dir
sort_concatmap.argument.target_path       = {{ job_directory }}
sort_concatmap.argument.NDPPPfill         = True
sort_concatmap.argument.stepname          = dpppconcat
sort_concatmap.argument.firstSB           = None
sort_concatmap.argument.truncateLastSBs	  = False

# convert the output of sort_concatmap into usable mapfile
do_sortmap_maps.control.kind              =  plugin
do_sortmap_maps.control.type              =  mapfilenamesFromMapfiles
do_sortmap_maps.control.mapfile_groupmap  =  sort_concatmap.output.groupmapfile.mapfile
do_sortmap_maps.control.mapfile_datamap   =  sort_concatmap.output.mapfile.mapfile

# concatenate all measurement sets into one
dppp_concat.control.type                  = dppp
dppp_concat.control.max_per_node          = {{ num_proc_per_node }}
dppp_concat.control.error_tolerance       = {{ error_tolerance }}
dppp_concat.control.mapfile_out           = do_sortmap_maps.output.groupmap
dppp_concat.control.mapfiles_in           = [do_sortmap_maps.output.datamap]
dppp_concat.control.inputkey              = msin
dppp_concat.argument.msin.datacolumn      = DATA
dppp_concat.argument.msin.missingdata     = True
dppp_concat.argument.msin.orderms         = False
dppp_concat.argument.msout.datacolumn     = DATA
dppp_concat.argument.msout.writefullresflag = False
dppp_concat.argument.msout.overwrite      = True
dppp_concat.argument.steps                = []
dppp_concat.argument.numthreads           = {{ max_dppp_threads }} 

# derive the closure phase
closure_phase.control.type                = pythonplugin
closure_phase.control.executable          = {{ closure_phase_script }}
closure_phase.argument.flags              = [dppp_concat.output.mapfile, {{ closure_phase_stations }}]

# clean up the individual subband files -- keep only the concatenated calibrator data
delete_intermediate_files.control.kind		  = recipe
delete_intermediate_files.control.type		  = executable_args
delete_intermediate_files.control.executable	  = /bin/rm
delete_intermediate_files.control.mapfile_in	  = dppp_phaseup.output.mapfile
delete_intermediate_files.control.inputkey	  = tempfiles
delete_intermediate_files.control.arguments	  = [-r,tempfiles]


##################################################################
#                                                               ##
#    		     DELAY CALIBRATION  		        ##
#                                                               ##
##################################################################

# get a list of the closure phase plots
createmap_plots.control.kind            = plugin
createmap_plots.control.type            = createMapfile
createmap_plots.control.method          = mapfile_from_folder
createmap_plots.control.mapfile_dir     = input.output.mapfile_dir
createmap_plots.control.filename        = createmap_plots.mapfile
createmap_plots.control.folder          = {{ job_directory }}
createmap_plots.control.pattern         = *.png

# create the results mapfile 
destmap_plots.control.kind            =  plugin
destmap_plots.control.type            =  makeResultsMapfile
destmap_plots.control.mapfile_dir     =  input.output.mapfile_dir
destmap_plots.control.filename        =  destmap_plots.mapfile
destmap_plots.control.mapfile_in      =  createmap_plots.output.mapfile
destmap_plots.control.target_dir      =  {{ inspection_directory }}

# move the inspection plots
cp_closure_phase_png.control.kind         = recipe
cp_closure_phase_png.control.type         = executable_args
cp_closure_phase_png.control.executable   = /bin/cp
cp_closure_phase_png.control.mapfiles_in  = [createmap_plots.output.mapfile,destmap_plots.output.mapfile]
cp_closure_phase_png.control.inputkeys    = [source,destination]
cp_closure_phase_png.control.arguments    = [source,destination]

# get a mapfile of the closure phase file
closure_phase_file.control.kind 	  = plugin
closure_phase_file.control.type	  	  = createMapfile
closure_phase_file.control.method	  = mapfile_from_folder
closure_phase_file.control.mapfile_dir 	  = input.output.mapfile_dir
closure_phase_file.control.filename	  = closure_phase_file.mapfile
closure_phase_file.control.folder	  = {{ job_directory }}
closure_phase_file.control.pattern	  = closure*.txt

# automatically find the best calibrator 
find_delay_cal.control.kind		  = plugin
find_delay_cal.control.type		  = DelayCalToMapfile
find_delay_cal.control.mapfile_dir	  = input.output.mapfile_dir
find_delay_cal.control.mapfile_out	  = find_delay_cal.mapfile
find_delay_cal.control.closurePhaseMap    = closure_phase_file.output.mapfile

# generate the calibrator model with skynet
delay_cal_model.control.type		  = pythonplugin
delay_cal_model.control.executable	  = {{ skynet_script }}
delay_cal_model.argument.flags		  = [find_delay_cal.output.mapfile]
delay_cal_model.argument.self_cal_script  = {{ self_cal_and_imaging_script }}
delay_cal_model.argument.mode		  = 2
delay_cal_model.argument.closure_tels	  = {{ closure_phase_stations }}
delay_cal_model.argument.cthr		  = 2.0 ## until using data that isn't test data
delay_cal_model.argument.model_only	  = 1
delay_cal_model.argument.firstnpy	  = {{ firstnpy_file }}

# generate mapfile with the parmDB names to be used in the gsmcal steps
delay_cal_model_map.control.kind               =  plugin
delay_cal_model_map.control.type               =  createMapfile
delay_cal_model_map.control.method             =  add_suffix_to_file
delay_cal_model_map.control.mapfile_in         =  find_delay_cal.output.mapfile
delay_cal_model_map.control.add_suffix_to_file =  /skymodel
delay_cal_model_map.control.mapfile_dir        =  input.output.mapfile_dir
delay_cal_model_map.control.filename           =  delay_cal_model_map.mapfile

# generate gain solutions for clock/tec separation using BBS
calib_cal.control.type             =  python-calibrate-stand-alone
calib_cal.control.max_per_node     =  {{ num_proc_per_node }}
calib_cal.control.error_tolerance  =  {{ error_tolerance }}
calib_cal.argument.force           =  True
calib_cal.argument.observation     =  find_delay_cal.output.mapfile  # mapfile for the NDPPP-ed calibrator data
calib_cal.argument.parset          =  {{ delay_cal_parset }}
calib_cal.argument.catalog         =  delay_cal_model_map.output.mapfile

# import all instrument tables into one LoSoTo file
h5imp_cal.control.type            =  pythonplugin
h5imp_cal.control.executable      =  {{ losoto_importer }}
h5imp_cal.control.error_tolerance =  {{ error_tolerance }}
h5imp_cal.argument.flags          =  [find_delay_cal.output.mapfile,h5imp_cal_losoto.h5] 
h5imp_cal.argument.instrument     =  /instrument
h5imp_cal.argument.solsetName     =  sol000
h5imp_cal.argument.compression    =  7

# copy the LoSoTo file to the inspection_directory
copy_h5imp_cal.control.kind               =  recipe
copy_h5imp_cal.control.type               =  executable_args
copy_h5imp_cal.control.executable         =  /bin/cp
copy_h5imp_cal.control.mapfile_in         =  h5imp_cal.output.h5parm.mapfile
copy_h5imp_cal.control.inputkey           =  source
copy_h5imp_cal.control.arguments          =  [source,{{ inspection_directory }}]

# try losoto clock/tec fitting
fitclock.control.kind                                    =  recipe
fitclock.control.type                                    =  executable_args
fitclock.control.executable                              =  {{ losoto_executable }}
fitclock.control.max_per_node                            =  {{ num_proc_per_node }}
fitclock.control.parsetasfile                            =  True
fitclock.control.args_format                             =  losoto
fitclock.control.mapfiles_in                             =  [h5imp_cal.output.h5parm.mapfile]
fitclock.control.inputkeys                               =  [hdf5file]
fitclock.argument.flags                                  =  [hdf5file]
fitclock.argument.LoSoTo.Steps                           =  [ClockTec,plotCLOCK,plotTEC]
fitclock.argument.LoSoTo.Solset                          =  [sol000]
fitclock.argument.LoSoTo.Soltab                          =  []
fitclock.argument.LoSoTo.SolType                         =  []
fitclock.argument.LoSoTo.ant                             =  []
fitclock.argument.LoSoTo.pol                             =  []
fitclock.argument.LoSoTo.dir                             =  []
fitclock.argument.LoSoTo.Steps.ClockTec.Operation        =  CLOCKTEC
fitclock.argument.LoSoTo.Steps.ClockTec.Soltab           =  [sol000/phase000]
fitclock.argument.LoSoTo.Steps.ClockTec.CombinePol       =  True
fitclock.argument.LoSoTo.Steps.ClockTec.FlagBadChannels  =  False
fitclock.argument.LoSoTo.Steps.ClockTec.Fit3rdOrder      =  False
fitclock.argument.LoSoTo.Steps.ClockTec.Circular         =  False
fitclock.argument.LoSoTo.Steps.plotCLOCK.Operation       =  PLOT
fitclock.argument.LoSoTo.Steps.plotCLOCK.Soltab          =  [sol000/clock000]
fitclock.argument.LoSoTo.Steps.plotCLOCK.Axes            =  [time]
fitclock.argument.LoSoTo.Steps.plotCLOCK.TableAxis       =  ant
fitclock.argument.LoSoTo.Steps.plotCLOCK.Prefix          =  {{ inspection_directory }}/losoto_clock
fitclock.argument.LoSoTo.Steps.plotCLOCK.PlotFlag        =  False
fitclock.argument.LoSoTo.Steps.plotTEC.Operation         =  PLOT
fitclock.argument.LoSoTo.Steps.plotTEC.Soltab            =  [sol000/tec000]
fitclock.argument.LoSoTo.Steps.plotTEC.Axes              =  [time]
fitclock.argument.LoSoTo.Steps.plotTEC.TableAxis         =  ant
fitclock.argument.LoSoTo.Steps.plotTEC.Prefix            =  {{ inspection_directory }}/losoto_tec
fitclock.argument.LoSoTo.Steps.plotTEC.PlotFlag          =  False



#fitclock.control.kind             = recipe
#fitclock.control.type             = executable_args
#fitclock.control.mapfile_in       = h5imp_cal.output.h5parm.mapfile
#fitclock.control.executable       = {{ fitclock_script }}
# order for arguments is: [<input-filename>,<output-filename-base>,<NumThreads>]
#fitclock.control.arguments        = [h5gvds,caldata_transfer,{{ num_proc_per_node }}]
#fitclock.control.inputkey         = h5gvds

# run the script that filters the amplitudes
ampl.control.kind             = recipe
ampl.control.type             = executable_args
ampl.control.mapfile_in       = h5imp_cal.output.h5parm.mapfile
ampl.control.executable       = {{ fitamps_script }}
# order for arguments is: [<input-filename>,<output-filename-base>,<num-ch/SB>,<subbans-to-flag>]
# subbans-to-flag = semicolon-sperated list of integers in double-quotes
# e.g.: ampl.control.arguments   = [h5gvds,caldata_transfer,4,"205;206;207"]
ampl.control.arguments        = [h5gvds,caldata_transfer,1,""]
ampl.control.inputkey         = h5gvds

# generate output plots
plots.control.kind             = recipe
plots.control.type             = executable_args
plots.control.mapfile_in       = h5imp_cal.output.h5parm.mapfile
plots.control.executable       = {{ plotsols_script }}
plots.control.skip_infile      = True
plots.control.arguments        = [caldata_transfer] # Needs "<output-filename-base>" from the fitclock and ampl steps

# generate a mapfile of all the diagnostic pngs
createmap_cal_pngs.control.kind            = plugin
createmap_cal_pngs.control.type            = createMapfile
createmap_cal_pngs.control.method          = mapfile_from_folder
createmap_cal_pngs.control.mapfile_dir     = input.output.mapfile_dir
createmap_cal_pngs.control.filename        = diagnostic_pngs.mapfile
createmap_cal_pngs.control.folder          = {{ job_directory }}
createmap_cal_pngs.control.pattern         = *.png

# copy the diagnostic pngs to the inspection directory
copy_cal_pngs.control.kind               =  recipe
copy_cal_pngs.control.type               =  executable_args
copy_cal_pngs.control.executable         =  /bin/cp
copy_cal_pngs.control.max_per_node       =  {{ num_proc_per_node_limit }}
copy_cal_pngs.control.mapfile_in         =  createmap_cal_pngs.output.mapfile
copy_cal_pngs.control.inputkey           =  source
copy_cal_pngs.control.arguments          =  [source,{{ inspection_directory }}]

# generate a mapfile of all the diagnostic txts
createmap_cal_txts.control.kind            = plugin
createmap_cal_txts.control.type            = createMapfile
createmap_cal_txts.control.method          = mapfile_from_folder
createmap_cal_txts.control.mapfile_dir     = input.output.mapfile_dir
createmap_cal_txts.control.filename        = diagnostic_txts.mapfile
createmap_cal_txts.control.folder          = {{ job_directory }}
createmap_cal_txts.control.pattern         = *.txt

# copy the diagnostic txts to the inspection directory
copy_cal_txts.control.kind               =  recipe
copy_cal_txts.control.type               =  executable_args
copy_cal_txts.control.executable         =  /bin/cp
copy_cal_txts.control.max_per_node       =  {{ num_proc_per_node_limit }}
copy_cal_txts.control.mapfile_in         =  createmap_cal_txts.output.mapfile
copy_cal_txts.control.inputkey           =  source
copy_cal_txts.control.arguments          = [source,{{ inspection_directory }}]

# create the cal_values_directory if needed
mk_cal_values_dir.control.kind               =  plugin
mk_cal_values_dir.control.type               =  makeDirectory
mk_cal_values_dir.control.directory          =  {{ cal_values_directory }}

# generate a mapfile of all the cal-value npys
createmap_cal_npys.control.kind            = plugin
createmap_cal_npys.control.type            = createMapfile
createmap_cal_npys.control.method          = mapfile_from_folder
createmap_cal_npys.control.mapfile_dir     = input.output.mapfile_dir
createmap_cal_npys.control.filename        = cal_value_npys.mapfile
createmap_cal_npys.control.folder          = {{ job_directory }} 
createmap_cal_npys.control.pattern         = *.npy

# copy the cal-value npys to the cal-values directory
copy_cal_npys.control.kind               =  recipe
copy_cal_npys.control.type               =  executable_args
copy_cal_npys.control.executable         =  /bin/cp
copy_cal_npys.control.max_per_node       =  {{ num_proc_per_node_limit }}
copy_cal_npys.control.mapfile_in         =  createmap_cal_npys.output.mapfile
copy_cal_npys.control.inputkey           =  source
copy_cal_npys.control.arguments          =  [source,{{ cal_values_directory }}]

# transfer solutions to MSs
transfer_delay_sols.control.type                 = pythonplugin
transfer_delay_sols.control.executable           = {{ transfer_delay_sols_script }}
transfer_delay_sols.argument.flags		 = [ndppp_prep_target.output.mapfile, {{ amp_sols_basename }}]
transfer_delay_sols.argument.npdir               = {{ cal_values_directory }}
#transfer_delay_sols.argument.output              = outputkey

# run NDPPP to apply the solutions to the target data
ndppp_apply_delay.control.type                         = dppp
ndppp_apply_delay.control.max_per_node                 = {{ num_proc_per_node }}
ndppp_apply_delay.control.error_tolerance              = {{ error_tolerance }}
ndppp_apply_delay.control.mapfiles_in                  = [ndppp_prep_target.output.mapfile,transfer_delay_sols.output.transfer_parmDB.mapfile]
ndppp_apply_delay.control.inputkeys                    = [input_file, parmdb_file]
ndppp_apply_delay.argument.numthreads                  = {{ max_dppp_threads }}
ndppp_apply_delay.argument.msin                        = input_file
ndppp_apply_delay.argument.msin.datacolumn             = CORRECTED_DATA
ndppp_apply_delay.argument.msin.baseline               = *&
ndppp_apply_delay.argument.msout                       = .
ndppp_apply_delay.argument.msout.datacolumn            = DATA
ndppp_apply_delay.argument.msout.writefullresflag      = False
ndppp_apply_delay.argument.steps                       = [applyClock, applyTec]
ndppp_apply_delay.argument.applyClock.type             = applycal
ndppp_apply_delay.argument.applyClock.parmdb           = parmdb_file
ndppp_apply_delay.argument.applyClock.correction       = clock
ndppp_apply_delay.argument.applyClock.updateweights    = false
ndppp_apply_delay.argument.applyTec.type	       = applycal
ndppp_apply_delay.argument.applyTec.parmdb	       = parmdb_file
ndppp_apply_delay.argument.applyTec.correction	       = tec
ndppp_apply_delay.argument.applyTec.updateweights      = false

##################################################################
#                                                               ##
#       CALIBRATOR LOOP 2: PHASE CALIBRATION		        ##
#                                                               ##
##################################################################

# Loop through the target phase calibrator canditates
#calibrator_loop2.control.kind                    = loop
#calibrator_loop2.control.type                    = conditional
#calibrator_loop2.control.loopcount               = 100
#calibrator_loop2.control.loopsteps               = [ run_self_cal ] ## , make_cal_results_mapfile, cp_cal_results ]

# Initialise file with all directions  -- THIS NEEDS TO BE CHANGED
#prep_dirs.control.kind                    = plugin
#prep_dirs.control.type                    = TargetListToMapfileX
#prep_dirs.control.mapfile_dir             = input.output.mapfile_dir
#prep_dirs.control.infile                  = ndppp_prep_target.output.mapfile
#prep_dirs.control.filename                = prep_dirs.mapfile
#prep_dirs.control.wd                      = {{ job_directory }}
#prep_dirs.control.nP                      = 3	# default was three
#prep_dirs.control.counter                 = calibrator_loop2.output.counter
#prep_dirs.control.target_file             = {{ calibrator_catalogue }} ## get_calibrator_directions

#run_self_cal.control.type		  = pythonplugin
#run_self_cal.control.executable           = {{ self_cal_and_imaging_script }}
#run_self_cal.argument.flags		  = [ dppp_concat.output.mapfile ]
#run_self_cal.argument.freq_range	  = 20

# make mapfile with the filenames of the results that we want
#make_cal_results_mapfile.control.kind            =  plugin
#make_cal_results_mapfile.control.type            =  makeResultsMapfile
#make_cal_results_mapfile.control.mapfile_dir     =  input.output.mapfile_dir
#make_cal_results_mapfile.control.filename        =  make_results_mapfile.mapfile
#make_cal_results_mapfile.control.mapfile_in      =  dppp_concat.output.mapfile
#make_cal_results_mapfile.control.target_dir      =  {{ calibrator_results_directory }}
#make_cal_results_mapfile.control.make_target_dir =  True

# move the final measurement set to the calibrator results directory  (probably not till after the phase-only calibrations)
#cp_cal_results.control.kind               =  recipe
#cp_cal_results.control.type               =  executable_args
#cp_cal_results.control.executable         =  /bin/cp
#cp_cal_results.control.max_per_node       =  {{ num_proc_per_node_limit }}
#cp_cal_results.control.mapfiles_in        =  [dppp_concat.output.mapfile,make_results_mapfile.output.mapfile]
#cp_cal_results.control.inputkeys          =  [source,destination]
#cp_cal_results.control.arguments          =  [source,destination]

# get a list of final images
createmap_fits.control.kind            = plugin
createmap_fits.control.type            = createMapfile
createmap_fits.control.method          = mapfile_from_folder
createmap_fits.control.mapfile_dir     = input.output.mapfile_dir
createmap_fits.control.filename        = createmap_fits.mapfile
createmap_fits.control.folder          = {{ job_directory }} 
createmap_fits.control.pattern         = *.fits

# move to the calibrator results directory
cp_fits.kind                	       	= recipe
cp_fits.type                 	       	= executable_args
cp_fits.control.executable   		= /bin/cp
cp_fits.control.max_per_node 		= {{ num_proc_per_node }}
cp_fits.control.mapfile_in   		= createmap_fits.output.mapfile
cp_fits.control.inputkey     		= source
cp_fits.control.arguments     		= [source,{{ calibrator_results_directory }}]

##################################################################
#                                                               ##
#                      TARGET IMAGING LOOP                      ##
#                                                               ##
##################################################################

# access lotss to provide a catalogue of sources to use
get_imaging_catalogue.control.type	   = pythonplugin
get_imaging_catalogue.control.executable   = {{ download_lotss_script }}
get_imaging_catalogue.argument.flags 	   = [ndppp_prep_target.output.mapfile]
get_imaging_catalogue.argument.ResultsFile = {{ target_catalogue }}
get_imaging_catalogue.argument.DoDownload  = {{ use_target_catalogue }}
get_imaging_catalogue.argument.Radius	   = 1.5

get_lbcs_catalogue.control.type                 = pythonplugin
get_lbcs_catalogue.control.executable           = {{ download_lbcs_script }}
get_lbcs_catalogue.argument.flags               = [ndppp_prep_target.output.mapfile]
get_lbcs_catalogue.argument.ResultsFile         = {{ calibrator_catalogue }}
get_lbcs_catalogue.argument.DoDownload          = {{ use_calibrator_catalogue }}
get_lbcs_catalogue.argument.Radius              = 1.5



# Loop through the target phase calibrator canditates
imaging_loop.control.kind                    = loop
imaging_loop.control.type                    = conditional
imaging_loop.control.loopcount               = 100
#imaging_loop.control.loopsteps               = [prep_dirs_img, dppp_phaseup_img, make_circ_img, make_concatmap_img, dppp_concat_img, run_imaging ]
imaging_loop.control.loopsteps               = [prep_dirs_img, dppp_phaseup_img, make_circ_img, make_concatmap_img, dppp_concat_img ]
## steps still to add: find phase solutions from nearest calibrator and copy them, run self-calibration sript (but only to image)

# Initialise file with all directions
prep_dirs_img.control.kind                    = plugin
prep_dirs_img.control.type                    = TargetListToMapfileX
prep_dirs_img.control.mapfile_dir             = input.output.mapfile_dir
prep_dirs_img.control.infile                  = ndppp_prep_target.output.mapfile ## ??
prep_dirs_img.control.filename                = prep_dirs_img.mapfile
prep_dirs_img.control.wd                      = {{ job_directory }}
prep_dirs_img.control.nP                      = 3 # default was three
prep_dirs_img.control.counter                 = imaging_loop.output.counter
prep_dirs_img.control.manual		      = {{ use_target_catalogue }}
prep_dirs_img.control.target_file             = {{ target_catalogue }}   ###

# shift, average and add up stations for tied array
dppp_phaseup_img.control.type                 = dppp
dppp_phaseup_img.control.max_per_node         = {{ num_proc_per_node }}
dppp_phaseup_img.control.mapfile_out          = prep_dirs_img.output.mapfile # tell the pipeline to give the output useful names
dppp_phaseup_img.argument.msin                = ndppp_prep_target.output.mapfile    # The input data.
dppp_phaseup_img.argument.msin.datacolumn     = CORRECTED_DATA
dppp_phaseup_img.argument.msout.datacolumn    = DATA
dppp_phaseup_img.argument.msout.overwrite     = True
dppp_phaseup_img.argument.steps               = [shift, avg, adder, filter]
dppp_phaseup_img.argument.shift.type          = phaseshift
dppp_phaseup_img.argument.shift.phasecenter   = prep_dirs_img.output.cords
dppp_phaseup_img.argument.avg.type            = squash
dppp_phaseup_img.argument.avg.freqstep        = {{ tgt_shift_avg_freqstep }}
dppp_phaseup_img.argument.avg.timestep        = {{ tgt_shift_avg_timestep }}
dppp_phaseup_img.argument.adder.type          = stationadder
dppp_phaseup_img.argument.adder.stations      = {{ phaseup_command }}
dppp_phaseup_img.argument.filter.type         = filter
dppp_phaseup_img.argument.filter.baseline     = {{ filter_command }}
dppp_phaseup_img.argument.filter.remove       = True
dppp_phaseup_img.argument.numthreads          = {{ max_dppp_threads }}  ## this supersedes the control.environment

# Convert to circular polarisation (in place)
make_circ_img.control.type                    = pythonplugin
make_circ_img.control.executable              = {{ execute_circ_conv_script }}
make_circ_img.argument.flags                  = [ dppp_phaseup_img.output.mapfile ]
make_circ_img.argument.cpath                  = {{ lin2circ_script }}
make_circ_img.argument.mode                   = lin2circ

# get a list of all subbands
make_concatmap_img.control.kind               =  plugin
make_concatmap_img.control.type               =  createMapfile
make_concatmap_img.control.method             =  mapfile_all_to_one
make_concatmap_img.control.mapfile_in         =  dppp_phaseup_img.output.mapfile
make_concatmap_img.control.mapfile_dir        =  input.output.mapfile_dir
make_concatmap_img.control.filename           =  make_concatmap_img.mapfile

# concatenate all of the files into one
dppp_concat_img.control.type                  = dppp
dppp_concat_img.control.max_per_node          = {{ num_proc_per_node }}
dppp_concat_img.argument.msin          	      = make_concatmap_img.output.mapfile  # use the mapfile from the make_concatmap step
dppp_concat_img.argument.msin.datacolumn      = DATA
dppp_concat_img.argument.msin.missingdata     = True    #\ these two lines will make DPPP generate dummy data when
dppp_concat_img.argument.msin.orderms         = False   #/ concatenating data
dppp_concat_img.argument.msout.datacolumn     = DATA
dppp_concat_img.argument.steps                = []
dppp_concat_img.argument.numthreads           = {{ max_dppp_threads }}  ## this supersedes the control.environment

#run_imaging.control.type 		      = pythonplugin
#run_imaging.control.executable		      = {{ self_cal_and_imaging_script }}

# make mapfile with the filenames of the results that we want
#make_results_mapfile.control.kind            =  plugin
#make_results_mapfile.control.type            =  makeResultsMapfile
#make_results_mapfile.control.mapfile_dir     =  input.output.mapfile_dir
#make_results_mapfile.control.filename        =  make_results_mapfile.mapfile
#make_results_mapfile.control.mapfile_in      =  check_unflagged_map.output.mapfile
#make_results_mapfile.control.target_dir      =  {{ results_directory }}
#make_results_mapfile.control.make_target_dir =  True
#make_results_mapfile.control.new_suffix      =  .pre-cal.ms

# move the results to where we want them
#cp_results.control.kind               =  recipe
#cp_results.control.type               =  executable_args
#cp_results.control.executable         =  /bin/cp
#cp_results.control.max_per_node       =  {{ num_proc_per_node_limit }}
#cp_results.control.mapfiles_in        =  [check_unflagged_map.output.mapfile,make_results_mapfile.output.mapfile]
#cp_results.control.inputkeys          =  [source,destination]
#cp_results.control.arguments          =  [source,destination]

##################################################################
#                                                               ##
#                   END OF PIPELINE	                        ##
# 		                                                ##
##################################################################
